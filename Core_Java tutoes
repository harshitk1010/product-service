CORE JAVA 

=====
CACHING..

@Cacheable: Caches the result of a method based on its parameters.
@CachePut: Updates the cache with the method’s result.
@CacheEvict: Removes data from the cache.
@Caching: Allows combining multiple caching annotations using a single method.

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product getProductById(Long id) {
        // Simulate a slow database query
        try {
            Thread.sleep(3000); // Simulates a delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return new Product(id, "Sample Product");
    }
}

In this example, the getProductById method is annotated with @Cacheable. The first time the method is called with a specific id, the result is stored in the cache. Subsequent calls with the same id retrieve the result from the cache instead of executing the method again.
@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    // Update product logic
    return product;
}
@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id) {
    // Delete product logic
}
@CacheEvict(value = "products", allEntries = true)
public void clearCache() {
    // Logic to clear cache
}
---
Redis Server is Running at Some Address:
Redis Accepts Multiple TCP Connections Through Clients: 
Redis beautifully exploits the fact that network I/O is much time taking then Redis’s in-memory operations (which are atomic) and thus redis can provide high throughput, low latency and this apparent but performant concurrency.

 low latency and high throughput observed in Redis caching--
Cache Expiration: If using an external cache provider, configure cache expiration to avoid stale data. For example, in Redis, you can set TTL (Time-To-Live) for cache entries.

=======================================

SPRING TRANSACTION;
https://medium.com/@alxkm/spring-transactions-best-practices-and-problems-ed2526777716
Transactional management is crucial in any application, especially in Spring-based applications where it plays a pivotal role in ensuring data integrity and consistency.
programmatic and declarative transaction management. Declarative management, using annotations like @Transactional, is generally preferred as it keeps the code cleaner and separates transaction management from business logic.

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    @Transactional
    public void updateProductPrice(Long productId, double newPrice) {
        Product product = productRepository.findById(productId);
        if (product != null) {
            product.setPrice(newPrice);
            productRepository.save(product);
        }
    }
}
// updateProductPrice method is annotated with @Transactional, indicating that it should be executed within a transaction. Inside the method, we fetch a Product entity by its ID, update its price, and then save it back to the database. If any exception occurs during the execution of this method, the transaction will be rolled back, ensuring data consistency.

@Transactional(rollbackFor = Exception.class)
    public void updateProductPrice(Long productId, double newPrice) throws ProductNotFoundException {
        Product product = productRepository.findById(productId);
        if (product == null) {
            throw new ProductNotFoundException("Product not found with ID: " + productId);
        }
        try {
            product.setPrice(newPrice);
            productRepository.save(product);
        } catch (Exception e) {
            // Log the exception or perform any necessary cleanup
            // Rollback will occur for any exception due to rollbackFor = Exception.class
            throw new ProductUpdateException("Failed to update product price", e);
        }
Spring-based applications maintain data integrity, scalability, and performance, even under heavy transactional loads..
Ensuring atomicity, consistency, isolation, and durability (ACID properties) in distributed transactions
Declarative Transaction Management: - @Transactional
Choosing the Right Propagation Level: - optimizing performance and resource utilization.
Handling Exceptions Appropriately:  - rollbackFor and noRollbackFor, ensures data consistency and graceful error recovery.
Implementing Retry Logic for Optimistic Locking: - 
Keeping Transactions Short and Simple: -

====================
SPRING PAGINATION
https://medium.com/@AlexanderObregon/paginating-api-results-with-spring-boot-and-spring-data-b00b5cddb41c










===============
KAFKA MULTILPE MICOSERVICE COMMUNICATION-








DSA/JAVA8
=============





==============
collection
https://medium.com/@alxkm/choosing-the-right-collection-in-java-c59784fdc9c8


