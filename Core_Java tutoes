CORE JAVA 

=====
CACHING..

@Cacheable: Caches the result of a method based on its parameters.
@CachePut: Updates the cache with the method’s result.
@CacheEvict: Removes data from the cache.
@Caching: Allows combining multiple caching annotations using a single method.

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product getProductById(Long id) {
        // Simulate a slow database query
        try {
            Thread.sleep(3000); // Simulates a delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return new Product(id, "Sample Product");
    }
}

In this example, the getProductById method is annotated with @Cacheable. The first time the method is called with a specific id, the result is stored in the cache. Subsequent calls with the same id retrieve the result from the cache instead of executing the method again.
@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    // Update product logic
    return product;
}
@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id) {
    // Delete product logic
}
@CacheEvict(value = "products", allEntries = true)
public void clearCache() {
    // Logic to clear cache
}
---
Redis Server is Running at Some Address:
Redis Accepts Multiple TCP Connections Through Clients: 
Redis beautifully exploits the fact that network I/O is much time taking then Redis’s in-memory operations (which are atomic) and thus redis can provide high throughput, low latency and this apparent but performant concurrency.

 low latency and high throughput observed in Redis caching--
Cache Expiration: If using an external cache provider, configure cache expiration to avoid stale data. For example, in Redis, you can set TTL (Time-To-Live) for cache entries.

=======================================

SPRING TRANSACTION;
https://medium.com/@alxkm/spring-transactions-best-practices-and-problems-ed2526777716

Transactional management is crucial in any application, especially in Spring-based applications where it plays a pivotal role in ensuring data integrity and consistency.
programmatic and declarative transaction management. Declarative management, using annotations like @Transactional, is generally preferred as it keeps the code cleaner and separates transaction management from business logic.

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    @Transactional
    public void updateProductPrice(Long productId, double newPrice) {
        Product product = productRepository.findById(productId);
        if (product != null) {
            product.setPrice(newPrice);
            productRepository.save(product);
        }
    }
}
// updateProductPrice method is annotated with @Transactional, indicating that it should be executed within a transaction. Inside the method, we fetch a Product entity by its ID, update its price, and then save it back to the database. If any exception occurs during the execution of this method, the transaction will be rolled back, ensuring data consistency.

@Transactional(rollbackFor = Exception.class)
    public void updateProductPrice(Long productId, double newPrice) throws ProductNotFoundException {
        Product product = productRepository.findById(productId);
        if (product == null) {
            throw new ProductNotFoundException("Product not found with ID: " + productId);
        }
        try {
            product.setPrice(newPrice);
            productRepository.save(product);
        } catch (Exception e) {
            // Log the exception or perform any necessary cleanup
            // Rollback will occur for any exception due to rollbackFor = Exception.class
            throw new ProductUpdateException("Failed to update product price", e);
        }
Spring-based applications maintain data integrity, scalability, and performance, even under heavy transactional loads..
Ensuring atomicity, consistency, isolation, and durability (ACID properties) in distributed transactions
Declarative Transaction Management: - @Transactional
Choosing the Right Propagation Level: - optimizing performance and resource utilization.
Handling Exceptions Appropriately:  - rollbackFor and noRollbackFor, ensures data consistency and graceful error recovery.
Implementing Retry Logic for Optimistic Locking: - 
Keeping Transactions Short and Simple: -

====================
SPRING PAGINATION
https://medium.com/@AlexanderObregon/paginating-api-results-with-spring-boot-and-spring-data-b00b5cddb41c











===============
KAFKA MULTILPE MICOSERVICE COMMUNICATION-








DSA/JAVA8
=============





==============
collection
https://medium.com/@alxkm/choosing-the-right-collection-in-java-c59784fdc9c8

For Random Access Operations: ArrayList is significantly more efficient.
For Frequent Insertions/Deletions at Arbitrary Positions: LinkedList can be more efficient due to the lack of need to shift elements, but the traversal cost needs to be considered.
For Bulk Operations: ArrayList often performs better due to cache locality and less memory overhead.

HashMap - (Hash table.) - Use Case: Best for cases where fast access and insertion without any specific ordering of elements are required.
LinkedHashMap - (Hash table and doubly-linked list.) - Use Case: Best when iteration order needs to be predictable (e.g., maintaining the order of insertion or access order). Suitable for cache implementations (e.g., LRU cache).
TreeMap (Red-black tree)O(log n) -- Use Case: Best when sorted order of keys is required. Suitable for range queries or when natural ordering of keys is important.

HashMap is the most optimal for general use cases where the order of elements does not matter, providing the fastest insertion, deletion, and lookup operations on average.
LinkedHashMap is optimal when you need to maintain insertion order or access order while still having efficient operations comparable to HashMap.
TreeMap is optimal when you need a map that is always sorted, which is useful for range queries or ordered data.

HashSet  Use Case: Best for cases where you need fast operations and do not care about the order of elements.
Hash table
TreeSet(Red-black tree) -- Use Case: Best when you need the elements to be maintained in a sorted order, which is useful for range queries and ordered data retrieval.

HashSet generally provides better performance for basic operations (add, remove, contains) due to O(1) time complexity on average. TreeSet has higher time complexity ( O(log n)) but maintains elements in sorted order.

======

HOW to monitor memoory..
JVM Tools: 
Third-Party Monitoring Tools:
Heap Dumps:
Logging and Alerting:
Monitoring Java memory usage in production environments is crucial for detecting memory leaks, optimizing performance, preventing OutOfMemoryErrors, troubleshooting performance issues, and ensuring the overall stability and reliability of Java applications.

=======

How Spring AOPWorks
Configuration:

XML-based Configuration: Define aspects and advice in Spring configuration files.
Annotation-based Configuration: Use annotations like @Aspect, @Before, @After, @Around, etc., to define aspects and advice in the code.

1. Logging
AOP can be used to log method entry, exit, and exceptions across various layers of an application without cluttering the business logic with logging code.
2. Transaction Management
AOP can manage transactions declaratively, ensuring that business methods are executed within a transactional context without manually managing transaction boundaries.

logging, security, and transaction management, by separating these concerns from the core business logic

Before advice: Executed before a join point.
After advice: Executed after a join point, regardless of its outcome.
After returning advice: Executed after a join point completes normally.
After throwing advice: Executed if a method exits by throwing an exception.
Around advice: Executed around a join point, allowing to control the method execution and the result.

============



